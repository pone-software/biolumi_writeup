<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-99.9.9">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Bioluminescence Trigger Rate</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="main_files/libs/clipboard/clipboard.min.js"></script>
<script src="main_files/libs/quarto-html/quarto.js"></script>
<script src="main_files/libs/quarto-html/popper.min.js"></script>
<script src="main_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="main_files/libs/quarto-html/anchor.min.js"></script>
<link href="main_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="main_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="main_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="main_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="main_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content page-columns page-full" id="quarto-document-content">

<!-- 
  This is the default Quarto title block header (customize as required) 
  Learn more about Pandoc template syntax here: https://pandoc.org/MANUAL.html#templates
-->

<header id="title-block-header">
  <h1 id="title">Bioluminescence Trigger Rate</h1>
  <div id="page-properties">
    <div class="details">
      <div>Created By Author</div>
      <div>Yesterday at 12:00 PM • 8 min read</div>
    </div>
  </div>
</header>


<p>This document summarizes the study on the expected local coincidence (LC) trigger rate in the 16PMT POM due to bioluminescense (BL).</p>
<section id="assumptions" class="level1 page-columns page-full">
<h1>Assumptions</h1>
<p>BL emission from an individual organism is assumed to be pointlike, isotropic and monochromatic (420nm). The emission positions are distributed according to the <a href="https://github.com/MeighenBergerS/fourth_day">Fourth-Day</a> model, which assumes that BL is caused mainly by turbulence-induced shear forces. The positions available for sampling are shown in <a href="#fig-fd-empos">Figure&nbsp;1</a> . As BL emission is biological, we assume that the time emission profile is uniform on the time scales considered for this study.</p>
<div class="cell page-columns page-full" data-execution_count="3">

<div class="no-row-height column-margin column-container"><div class="cell-output cell-output-display" data-execution_count="10">
<div id="fig-fd-empos" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="main_files/figure-html/fig-fd-empos-output-1.svg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;1: Fourth Day Emission Positions</figcaption><p></p>
</figure>
</div>
</div></div></div>
</section>
<section id="probabilistic-model" class="level1">
<h1>Probabilistic Model</h1>
<p>Assuming that the detected photons are independent and that each PMT sees the same rate, we can model the coincidences with a binomial distribution. The success rate is given by the time window size <span class="math inline">\(T\)</span> and the single-pmt rate <span class="math inline">\(R\)</span>. We then ask for the probability of observing <span class="math inline">\(n_{\text{hit}}\)</span> in a given time window: <span class="math display">\[
\begin{align*}
T &amp;= 20~\mathrm{ns} \\
R &amp;= 10^5~\mathrm{Hz} \\
p_{\text{hit}} &amp;= R \cdot \frac{tw}{10^9~ \mathrm{ns/s}} \\
n_{\text{hit}} &amp;\sim \text{Binom}(n=16, p=p_{\text{hit}})
\end{align*}
\]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>This assumes that all PMTs see the <em>same</em> rate. Additionally, we only consider each PMT once per time-window. This is valid, as long as the success probability is small (small time windows).</p>
</div>
</div>
<p><a href="#fig-prob-lc">Figure&nbsp;2</a> shows the expected LC rates using the Binomial model.</p>
<div class="cell" data-execution_count="4">
<div class="cell-output cell-output-display" data-execution_count="11">
<div id="fig-prob-lc" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="main_files/figure-html/fig-prob-lc-output-1.svg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;2: Local coincidence rates from Binomial model</figcaption><p></p>
</figure>
</div>
</div>
</div>
</section>
<section id="photon-propagation-setup" class="level1">
<h1>Photon Propagation Setup</h1>
<p>Source positions are drawn from the Fourth-Day positional distribution. At each position, a monochromatic, isotropic emitter is placed. A fixed number of photons is emitted uniformely over a time range of <span class="math inline">\(10^7\)</span>ns. A P-OM receiver is placed at <span class="math inline">\((0, 0, 0)\)</span>. For each simulation run, a fixed number <span class="math inline">\(N\)</span> of emitters is drawn, each emitting <span class="math inline">\(10^9/N\)</span> photons. Photons are propagated with the <a href="https://github.com/PLEnuM-group/PhotonPropagation.jl">PhotonPropagation.jl</a> package, using the standard optical properties for Cascadia Basin.</p>
<p>After propagation, photons are attributed to the indivdual PMTs and are resampled according to their total weight (includes absorption in water and quantum efficiency).</p>
<p>In order to calculated the expected PMT rate in STRAW for each emitter configuration, an additional simulation is run, where the receiver is replaced by a single, upwards-facing PMT.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Angular acceptance is currently <em>not</em> taken into account (ie FOV is <span class="math inline">\(180^\circ\)</span>).</p>
</div>
</div>
</section>
<section id="trigger-logic" class="level1">
<h1>Trigger Logic</h1>
<p>A local-coindince trigger algorithm is run on all hits from each simulation run. The algorithm is implemented as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource julia number-lines code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1"></a><span class="st">"""</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="st">    lc_trigger(sorted_hits::AbstractDataFrame, time_window)</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="st">Calculate local-coincidence triggers for `sorted_hits` in `time_window`.</span></span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="st">The algorithm loops through all hits ``h_i``. When the next hit ``h_j`` is closer than the</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="st">time window ``</span><span class="sc">\\</span><span class="st">delta`` a new trigger is started. The trigger will accumulate all hits</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="st">``h_j`` that are within ``h_i + </span><span class="sc">\\</span><span class="st">delta``. Finally, a trigger is emitted when it includes</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="st">hits on at least two different PMTs.</span></span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="st">Returns a Vector of hit-time vectors.</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="st">"""</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="kw">function</span> <span class="fu">lc_trigger</span>(sorted_hits<span class="op">::</span><span class="dt">AbstractDataFrame</span>, time_window)</span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a>    triggers <span class="op">=</span> []</span>
<span id="cb1-16"><a href="#cb1-16"></a>    i <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> <span class="fu">nrow</span>(sorted_hits)</span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a>        lc_flag <span class="op">=</span> <span class="cn">false</span></span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a>        j <span class="op">=</span> i <span class="op">+</span> <span class="fl">1</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>        <span class="cf">while</span> j <span class="op">&lt;=</span> <span class="fu">nrow</span>(sorted_hits)</span>
<span id="cb1-23"><a href="#cb1-23"></a>            <span class="cf">if</span> (sorted_hits[j, <span class="op">:</span>time] <span class="op">-</span> sorted_hits[i, <span class="op">:</span>time]) <span class="op">&lt;=</span> time_window</span>
<span id="cb1-24"><a href="#cb1-24"></a>                lc_flag <span class="op">=</span> <span class="cn">true</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>            <span class="cf">else</span></span>
<span id="cb1-26"><a href="#cb1-26"></a>                <span class="cf">break</span></span>
<span id="cb1-27"><a href="#cb1-27"></a>            <span class="cf">end</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>            j <span class="op">+=</span> <span class="fl">1</span></span>
<span id="cb1-29"><a href="#cb1-29"></a>        <span class="cf">end</span></span>
<span id="cb1-30"><a href="#cb1-30"></a></span>
<span id="cb1-31"><a href="#cb1-31"></a>        <span class="cf">if</span> !lc_flag</span>
<span id="cb1-32"><a href="#cb1-32"></a>            i <span class="op">=</span> j</span>
<span id="cb1-33"><a href="#cb1-33"></a>            <span class="cf">continue</span></span>
<span id="cb1-34"><a href="#cb1-34"></a>        <span class="cf">end</span></span>
<span id="cb1-35"><a href="#cb1-35"></a></span>
<span id="cb1-36"><a href="#cb1-36"></a>        <span class="cf">if</span> <span class="fu">length</span>(<span class="fu">unique</span>(sorted_hits[i<span class="op">:</span>(j<span class="op">-</span><span class="fl">1</span>), <span class="op">:</span>pmt_id])) <span class="op">&gt;=</span> <span class="fl">2</span></span>
<span id="cb1-37"><a href="#cb1-37"></a>            <span class="fu">push!</span>(triggers, sorted_hits[i<span class="op">:</span>(j<span class="op">-</span><span class="fl">1</span>), <span class="op">:</span>])</span>
<span id="cb1-38"><a href="#cb1-38"></a>        <span class="cf">end</span></span>
<span id="cb1-39"><a href="#cb1-39"></a></span>
<span id="cb1-40"><a href="#cb1-40"></a>        i <span class="op">=</span> j</span>
<span id="cb1-41"><a href="#cb1-41"></a>    <span class="cf">end</span></span>
<span id="cb1-42"><a href="#cb1-42"></a>    <span class="cf">return</span> triggers</span>
<span id="cb1-43"><a href="#cb1-43"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The LC trigger is run for different time-windows: 10ns, 15ns, 20ns and 30ns.</p>
</section>
<section id="simulation-runs" class="level1">
<h1>Simulation Runs</h1>
<p>Simulation runs are performed for different numbers of BL emitters. For each run, a new set of BL emission positions is drawn. LC triggers are calculated per run. The result is grouped by the coincidence level (ie. the number of unique PMTs with at least one hit). The LC trigger rate is the calculated as: <span class="math display">\[
R_k = N_k \cdot \frac{n_{\text{sim}} \cdot 10^7 }{10^9} ,
\]</span> where <span class="math inline">\(N_k\)</span> is the number of triggers at LC level <span class="math inline">\(k\)</span>, <span class="math inline">\(n_{\text{sim}}\)</span> is the number of simulation runs for a given BL emitter number, and <span class="math inline">\(10^7\)</span> is the emission time window.</p>
</section>
<section id="result" class="level1">
<h1>Result</h1>
<p><a href="#fig-sim-lc">Figure&nbsp;3</a> shows a summary of the simulations. Based on the STRAW rates we expect up to 30kHz (40kHz) of triggers at LC2 for time windows of 10ns (20ns). The Binomial model works reasonable well for small time windows, but underpredicts the expected LC rates by up to an order of magnitude for larger time windows.</p>
<div class="cell" data-execution_count="6">
<div class="cell-output cell-output-display" data-execution_count="13">
<div id="fig-sim-lc" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="main_files/figure-html/fig-sim-lc-output-1.svg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;3: Simulated local coincidence rates for 10ns (left) and 20ns (right) time windows. The black lines shows the STRAW rate fraction above a given rate. The solid, colored lines show the coincidence rates expected from the binomial model.</figcaption><p></p>
</figure>
</div>
</div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>